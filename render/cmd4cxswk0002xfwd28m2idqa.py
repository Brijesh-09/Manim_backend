from manim import *

class AutoGeneratedScene(Scene):
    def construct(self):
        # Set up the scene
        self.camera.background_color = WHITE
        text_color = BLACK
        number_color = BLUE
        square_color = RED
        theorem_color = GREEN

        # Define the right triangle vertices
        A = np.array([0, 0, 0])
        B = np.array([4, 0, 0])
        C = np.array([0, 3, 0])

        # Create the right triangle
        triangle = Polygon(A, B, C, stroke_color=text_color, fill_color=GREY, fill_opacity=0.3)
        a_side = Line(A, B, color=text_color)
        b_side = Line(A, C, color=text_color)
        c_side = Line(B, C, color=text_color)

        # Labels for sides
        a_label = MathTex("a", color=text_color).move_to(a_side.get_center() + DOWN * 0.3)
        b_label = MathTex("b", color=text_color).move_to(b_side.get_center() + LEFT * 0.3)
        c_label = MathTex("c", color=text_color).move_to(c_side.get_center() + UP * 0.3)

        # Group the triangle and labels
        triangle_group = VGroup(triangle, a_side, b_side, c_side, a_label, b_label, c_label)
        self.play(Create(triangle_group))
        self.wait(1)

        # Create squares on each side
        square_a = Square(side_length=4, stroke_color=text_color, fill_color=square_color, fill_opacity=0.5).move_to(a_side.get_center()).shift(DOWN * 2)
        square_b = Square(side_length=3, stroke_color=text_color, fill_color=square_color, fill_opacity=0.5).move_to(b_side.get_center()).shift(LEFT * 1.5)
        square_c = Square(side_length=5, stroke_color=text_color, fill_color=square_color, fill_opacity=0.5).move_to(c_side.get_center()).shift((0.8, 1)) # Adjust shift for better positioning

        # Numbers inside the squares
        area_a = MathTex("a^2", color=number_color).move_to(square_a.get_center())
        area_b = MathTex("b^2", color=number_color).move_to(square_b.get_center())
        area_c = MathTex("c^2", color=number_color).move_to(square_c.get_center())

        # Animate the creation of the squares
        self.play(Create(square_a), Create(square_b), Create(square_c))
        self.play(Write(area_a), Write(area_b), Write(area_c))
        self.wait(1)

        # Camera pan to focus on each square
        self.play(self.camera.frame.animate.move_to(square_a))
        self.wait(0.5)
        self.play(self.camera.frame.animate.move_to(square_b))
        self.wait(0.5)
        self.play(self.camera.frame.animate.move_to(square_c))
        self.wait(0.5)
        self.play(self.camera.frame.animate.move_to(triangle)) # Back to the main triangle
        self.wait(1)

        # Pythagorean theorem equation
        theorem = MathTex("a^2 + b^2 = c^2", color=theorem_color).to_edge(UP)

        # Show equation
        self.play(Write(theorem))
        self.wait(1)

        # Prepare smaller squares to fill square_c
        small_squares_a = VGroup(*[Square(side_length=0.8, fill_color=square_color, fill_opacity=0.8, stroke_width=0) for _ in range(25)])
        small_squares_a.arrange_in_grid(5, 5, buff=0)
        small_squares_a.move_to(square_a.get_center())

        small_squares_b = VGroup(*[Square(side_length=0.6, fill_color=square_color, fill_opacity=0.8, stroke_width=0) for _ in range(25)])
        small_squares_b.arrange_in_grid(5, 5, buff=0)
        small_squares_b.move_to(square_b.get_center())

        # Animate moving squares
        self.play(
            Transform(square_a, small_squares_a),
            Transform(square_b, small_squares_b)
        )
        self.wait(1)

        # Define the target locations within square_c
        target_points_a = []
        target_points_b = []
        count = 0
        for i in range(5):
            for j in range(5):
                if count < 16: # a^2 = 16
                    target_points_a.append(square_c.get_center() + np.array([-2 + 0.8*j, -2 + 0.8*i, 0])) # Scaling to fit
                else:
                    target_points_b.append(square_c.get_center() + np.array([-2+ 0.6 * (j-2), -2+ 0.6 * (i-2), 0])) # Scaling to fit
                count+=1

        # Move the smaller squares to fill square_c
        animations = []
        count_a = 0
        count_b = 0
        for square in small_squares_a:
          if count_a < 16:
            animations.append(square.animate.move_to(target_points_a[count_a]))
            count_a +=1

        for square in small_squares_b:
            if count_b < 9:
                animations.append(square.animate.move_to(target_points_b[count_b]))
                count_b +=1

        self.play(*animations, run_time=5)
        self.wait(2)

        # Fade out everything
        self.play(FadeOut(triangle_group, square_a, square_b, square_c, theorem, small_squares_a, small_squares_b))
        self.wait(1)